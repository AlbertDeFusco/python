\documentclass[xcolor=table,10pt,final]{beamer}
\renewcommand\mathfamilydefault{\rmdefault}

\setbeamertemplate{navigation symbols}{}
\usepackage{amsmath,amsfonts,amssymb,pxfonts,xspace}
\usepackage{textcomp}
\usepackage{lmodern}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[T1]{fontenc}

\lstset{
    basicstyle=\footnotesize,
    keywordstyle=\color[rgb]{0.1,0.8,0.1}\bfseries,
    commentstyle=\color{blue},
    numbers=left,
    stringstyle=\ttfamily\color{red!50!brown},
    showstringspaces=false}
\lstset{literate=%
   *{0}{{{\color{red!20!violet}0}}}1
    {1}{{{\color{red!20!violet}1}}}1
    {2}{{{\color{red!20!violet}2}}}1
    {3}{{{\color{red!20!violet}3}}}1
    {4}{{{\color{red!20!violet}4}}}1
    {5}{{{\color{red!20!violet}5}}}1
    {6}{{{\color{red!20!violet}6}}}1
    {7}{{{\color{red!20!violet}7}}}1
    {8}{{{\color{red!20!violet}8}}}1
    {9}{{{\color{red!20!violet}9}}}1
}



\begin{document}

\title{Python: beyond the basics}
\author{Albert DeFusco}
\date{\today}


\frame{\titlepage}

\begin{frame}
  \frametitle{Functions}
  \begin{itemize}
    \item Doc strings
    \item Default values
    \item Optional arguments
    \item Returns
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Functions}
\begin{lstlisting}[language=Python]
def divide(x,y):
  """Divide takes two integers as input
  returns a tupe of quotient and remainder"""
  return x/y,x%y
\end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Mathematical Exercises}
  \begin{itemize}
    \item Write a function to differentiate another function
  \end{itemize}
\begin{equation*}
  f^{\prime}(x) \approx \frac{f(x+h) - f(x-h)}{2h}
\end{equation*}
\begin{itemize}
  \item<2-> $f(x)$ and $h$ are arguments
    \begin{itemize}
      \item make $h=0.01$ the default value
    \end{itemize}
  \item<2-> Practice with the following functions
    \begin{itemize}
      \item $f(x) = x^2$ at $x=1$
      \item $f(x) = cos(x)$ at $x=2\pi$
      \item $f(x) = e^{-2x^2}$ at $x=0$
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{recursions}
  \begin{equation*}
    n! = \prod_{k=1}^n k
  \end{equation*}
\begin{lstlisting}[language=Python]
def factorial(n):
  if(n==0):
    return 1
  return n*factorial(n-1)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Functions and variables}
  \begin{itemize}
    \item Functions are defined in {\tt def} blocks\\
      \begin{lstlisting}[language=python]
def pi(i):
  """Compute the ith term of the Wallis formula"""
  return 4.*i**2 / (4.*i**2 - 1)

  print pi.__doc__
      \end{lstlisting}
    \item Multiple returns are tuples\\
      \begin{lstlisting}[language=python]
def myFunction(x,y):
  return x**2,y*4

a,b = myFunction(y=2,x=8)
      \end{lstlisting}
    \item Functions are objects
    \item Variables are passed by value
    \item Types are still implicit
    \item Global variables can be defined
      \begin{itemize}
        \item But not for passed variables
        \item Globals are not good OOP practice
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Functions and mutability}
  \begin{lstlisting}[language=python]
>>> def try_to_modify(x, y, z):
...     x = 23
...     y.append(42)
...     z = [99]
...     print(x)
...     print(y)
...     print(z)
...
>>> a = 77
>>> b = [99]
>>> c = [28]
>>> try_to_modify(a, b, c)
23
[99, 42]
[99]
>>> print(a)
77
>>> print(b)
[99, 42]
>>> print(c)
[28]
  \end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Modules}
  \begin{itemize}
    \item Import {\tt math.py} such that {\tt math} becomes the object name\\
      \lstinline[language=python]|import math|\\
      \lstinline[language=python]|print math.pi|\\
      \lstinline[language=python]|print math.sin(math.pi)|
    \item Alternatives
      \begin{itemize}
        \item \lstinline[language=python]|from math import sin|
        \item \lstinline[language=python]|import math as maths|
      \end{itemize}
    \item Avoid
      \begin{itemize}
        \item \lstinline[language=python]|from math import *|
      \end{itemize}
  \end{itemize}
  \vskip1cm
{\it If you can imagine it, someone probably has a module that can do it.}\\
{\scriptsize \url{http://docs.python.org/2/py-modindex.html}}\\
{\scriptsize \url{http://wiki.python.org/moin/UsefulModules}}\\
\end{frame}

\begin{frame}[fragile]
  \frametitle{Classes}
  \begin{lstlisting}[language=python]
  class Molecule(object):
    """Molecules have a name and chemical formula"""
    #Print the above message with "print <instance>.__doc__"
    weight=0
    def __init__(self,name)
      self.name = name
    def setName(self,name):
      self.name = name
    def setFormula(self,formula):
      self.formula=formula
    def computeWeight(self)
      try:
        weight = f(formula)
      except:
        print "the chemical formula was not set"
        return None
   \end{lstlisting}
   \begin{itemize}
     \item Private members and methods are name mangled
       \begin{itemize}
         \item \lstinline[language=python]|__name| becomes \lstinline[language=python]|_classname_name| at runtime
         \item Somewhat taboo in Python culture
       \end{itemize}
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Overloading}
  Change or the define the behavior of operations
  \begin{lstlisting}[language=python]
class Molecule(object):
...
  def __add__(self, other):
  return self.weight+other.weight,self.formula+other.formula
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Inheritance}
  \begin{itemize}
    \item Child classes can be more {\it specific} than the parent\\
      \begin{lstlisting}[language=python]
class Chromophore(Molecule):
  """Chromophore is a special type of Molecule"""
  def absorption(self):
    """Compute absorption spectrum"""
    self.specturm = absorb(formula)
      \end{lstlisting}
    \item Subclasses can override the superclass$^\dagger$\\
  \begin{lstlisting}[language=python]
class Polymer(Molecule):
  """A polymer has a monomer (molecule) and a repeat"""
  def __init__(self,name,lenght):
    super(Polymer,self).__init__("poly"+name)
    self.lenght = lenght
  def grow(self,length):
    self.weight+=length*self.weight/self.length
    self.length+=length
  def setFormula(self,formula):
    self.formula="["+formula+"]"+str(self.length)
  def setWeight(self,weight):
    self.weight=weight*self.length
  \end{lstlisting}
  \end{itemize}
  $^\dagger${\scriptsize Polymorphism in Python is achieved when classes implement the same methods, which reduces the number of {\tt if} statements}
\end{frame}

\begin{frame}
  \frametitle{Error handling}
  \begin{itemize}
    \item unix return codes
    \item stderr
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Exception Object}
  \begin{itemize}
    \item Exceptions represent errors
    \item Exceptions are built-in at the lowest level
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Checking for errors}
  \begin{itemize}
    \item avoid checking (if) for all possible errors
  \end{itemize}
  \begin{lstlisting}[language=Python]
def celcius(tempF):
\end{lstlisting}
\end{frame}

\end{document}
